import 'package:googleapis/firestore/v1.dart';
import 'package:googleapis_auth/googleapis_auth.dart';
import 'package:storage_fields/src/firestore_implementation/utils/index.dart';
import 'package:storage_fields/src/services/index.dart';

class FirestoreService {
  final FirestoreApi _api;
  final BaseConfigurationService _baseConfigurationService;
  FirestoreService({
    required AuthClient authClient,
    required BaseConfigurationService baseConfigurationService,
  })  : _api = FirestoreApi(authClient),
        _baseConfigurationService = baseConfigurationService;

  /// Creates and persists a new firestore document.
  ///
  /// Parameters:
  ///
  /// [root] - Required. The parent resource. For example:
  /// 'projects/l3m-development-database/databases/(default)/documents'
  ///
  /// [collectionId] - Required. The collection ID, relative to `root`.For example: `users`.
  ///
  /// [firestoreJson] - Required. The document content in firestore json.
  /// Import the firestore_helper and use the toFirestoreJson extension to encode a
  /// raw map to firestore json.
  ///
  /// [documentId] - The document ID to use for this document.
  /// Optional. If not specified, an ID will be generated by firestore.
  ///
  /// Completes with the new [Document] on success.
  ///
  /// Completes with null on failure.
  ///
  Future<Document?> write({
    required String root,
    required String collectionId,
    required Map<String, Map<String, dynamic>> firestoreJson,
    String? documentId,
  }) async {
    final doc = Document.fromJson(firestoreJson);

    try {
      return await _api.projects.databases.documents.createDocument(
        doc,
        root,
        collectionId,
        documentId: documentId,
      );
    } catch (error) {
      print('Error creating firestore document: $error');
    }

    return null;
  }

  /// Updates or creates a firestore document with the option to overwrite or merge data.
  ///
  /// Parameters:
  ///
  /// [firestoreJson] - Required. The document content in firestore json.
  /// Import the firestore_helper and use the toFirestoreJson extension to encode a
  /// raw map to firestore json.
  ///
  /// [name] - Required. The full document path with document id.
  ///
  /// [merge] - If true the supplied data will be merged into the resulting document.
  ///         - If false any existing data will be replaced.
  /// Optional. Defaults to true.
  ///
  /// [documentExists] - If true, the target document must exist.
  ///                  - If false, the target document must not exist.
  ///                  - If null, the target document will be created or updated regardless.
  /// Optional - defaults to null.
  ///
  /// Completes with the new [Document] on success.
  ///
  /// Throws error on failure.
  ///
  Future<Document> update({
    required Map<String, Map<String, dynamic>> firestoreJson,
    required String name,
    bool merge = true,
    bool? documentExists,
  }) async {
    return updateFromDocument(
      document: Document.fromJson(firestoreJson),
      name: name,
      merge: merge,
      documentExists: documentExists,
    );
  }

  /// Updates or creates a firestore document with the option to overwrite or merge data.
  ///
  /// Parameters:
  ///
  /// [document] - Required. The populated document to persist.
  ///
  /// [name] - Required. The full document path with document id.
  ///
  /// [merge] - If true the supplied data will be merged into the resulting document.
  ///         - If false any existing data will be replaced.
  /// Optional. Defaults to true.
  ///
  /// [documentExists] - If true, the target document must exist.
  ///                  - If false, the target document must not exist.
  ///                  - If null, the target document will be created or updated regardless.
  /// Optional - defaults to null.
  ///
  /// [currentDocumentUpdateTime] - When set, the target document must exist
  /// and have been last updated at that time. Timestamp must be microsecond
  /// aligned. If time is different, then error will be thrown
  ///
  /// Completes with the new [Document] on success.
  ///
  /// Throws error on failure.
  ///
  // ignore: long-parameter-list
  Future<Document> updateFromDocument({
    required Document document,
    required String name,
    bool merge = true,
    bool? documentExists,
    String? currentDocumentUpdateTime,
  }) async {
    List<String>? updateMask;
    if (merge) {
      updateMask = document.fields?.toFirestoreMask();
    }

    return _api.projects.databases.documents.patch(
      document,
      name,
      updateMask_fieldPaths: updateMask,
      currentDocument_exists: documentExists,
      currentDocument_updateTime: currentDocumentUpdateTime,
    );
  }

  /// Returns documents matching supplied criteria
  ///
  /// [parent] - If supplied, should be the full path of the document containing the collections.
  /// Optional - Defaults to root documents path
  ///
  Future<List<Document>> queryDocuments({
    required DocumentQuery documentQuery,
    String? parent,
  }) async {
    try {
      final query = await _api.projects.databases.documents.runQuery(
        documentQuery.generateQuery(),
        parent ?? _baseConfigurationService.firestoreDocumentsPath,
      );

      return query.fold<List<Document>>([], (previousValue, element) {
        final document = element.document;
        if (document == null) {
          return previousValue;
        }

        return previousValue..add(document);
      });
    } catch (error) {
      print('Error while querying documents: $error');

      return [];
    }
  }

  /// Updates document based on current data. If document version would be changed
  /// while update, transaction will be launched again with new data
  ///
  /// Parameters:
  ///
  /// [name] - Required. The full document path with document id.
  /// F.e. 'firestoreDocumentsPath/collection/documentId';
  ///
  /// [patcher] - Required. Function that return data to write based on current
  ///
  Future<Document> runUpdateTransaction({
    required String name,
    required Document Function(Document? document) patcher,
  }) async {
    String? targetDocumentUpdateTime;
    try {
      final currentDocument = await getDocument(name: name);
      targetDocumentUpdateTime = currentDocument?.updateTime;
      final updatedDocument = patcher(currentDocument);

      return updateFromDocument(
        document: updatedDocument,
        name: name,
        currentDocumentUpdateTime: targetDocumentUpdateTime,
      );
    } catch (error) {
      final currentDocument = await _api.projects.databases.documents.get(name);
      // Retry transaction if there were an error because of update time changed
      if (targetDocumentUpdateTime != currentDocument.updateTime &&
          targetDocumentUpdateTime != null) {
        return runUpdateTransaction(name: name, patcher: patcher);
      }

      rethrow;
    }
  }

  Future<Document?> getDocument({
    required String name,
  }) async {
    try {
      return await _api.projects.databases.documents.get(name);
    } on DetailedApiRequestError catch (error) {
      if (error.status == 404) {
        return null;
      }

      rethrow;
    }
  }

  /// Get multiple documents by names
  /// [documentNames] - Required. List of document names.
  /// [databasePath] - Required. Path to database. For example:
  /// 'projects/l3m-development-database/databases/(default)'
  ///
  Future<List<Document?>?> batchGetDocuments(
    List<String> documentNames,
    String databasePath,
  ) async {
    try {
      final request = BatchGetDocumentsRequest(
        documents: documentNames,
      );

      final result = await _api.projects.databases.documents.batchGet(
        request,
        databasePath,
      );

      return result.map((responseElement) => responseElement.found).toList();
    } on DetailedApiRequestError catch (error) {
      if (error.status == 404) {
        return null;
      }

      rethrow;
    }
  }

  /// Deletes supplied documents
  ///
  Future<bool> delete({required List<Document> documents}) async {
    try {
      await Future.wait(
        documents.fold<List<Future<void>>>([], (result, doc) {
          final documentName = doc.name;
          if (documentName == null) {
            return result;
          }

          return result
            ..add(
              _api.projects.databases.documents.delete(documentName),
            );
        }),
      );

      return true;
    } catch (exception) {
      print('Error when trying to delete documents, message: $exception');

      return false;
    }
  }
}
